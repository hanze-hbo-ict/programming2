{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Programming exercises \u00b6 On these pages you'll find accompanying exercises for the module Programming 2 of the master Data Science for Life Science. Schedule and links \u00b6 weeknumber subject(s) 1 Introduction, SOLID principles static code analysis 2 classes and instances, methods constructors and destructors 3 creating complex classes 4 dunders, testing, git test driven development 5 functions as parameters dependency injection 6 code from scratch, modules UML and design patterns 7 Lessons learned, wrap up pitches Final assignment \u00b6 At the end of this module, you are challenged to put the lessons learned into practice. Given the knowledge you have gained during this module, can you come up with interesting and non-trivial refactoring candidates for an existing code base? Can you describe and argue what steps would make a code-base better \u2013 in terms of maintainability, readability, flexibility, or transferability? Find a code base for your analysis. You can use your own code base from last semester, but you are also free to find one of github. Make a short description of the context in which this code base is developed, which problem it tries to solve and in what way it succeeds in doing so (if at all). Next, come up with a static code analysis in which you describe the current state of the code base. Think about the steps we took in exercise 1 . After you have done this, you should be able to identify and describe certain code smells . Describe these smells (in somewhat detail, including the programming code) and make suggestions for improvements. All this should return in a small report of about five to ten pages (including images and code listings). You don't have to perform the refactoring \u2013 a description will suffice.","title":"Programming exercises"},{"location":"index.html#programming-exercises","text":"On these pages you'll find accompanying exercises for the module Programming 2 of the master Data Science for Life Science.","title":"Programming exercises"},{"location":"index.html#schedule-and-links","text":"weeknumber subject(s) 1 Introduction, SOLID principles static code analysis 2 classes and instances, methods constructors and destructors 3 creating complex classes 4 dunders, testing, git test driven development 5 functions as parameters dependency injection 6 code from scratch, modules UML and design patterns 7 Lessons learned, wrap up pitches","title":"Schedule and links"},{"location":"index.html#final-assignment","text":"At the end of this module, you are challenged to put the lessons learned into practice. Given the knowledge you have gained during this module, can you come up with interesting and non-trivial refactoring candidates for an existing code base? Can you describe and argue what steps would make a code-base better \u2013 in terms of maintainability, readability, flexibility, or transferability? Find a code base for your analysis. You can use your own code base from last semester, but you are also free to find one of github. Make a short description of the context in which this code base is developed, which problem it tries to solve and in what way it succeeds in doing so (if at all). Next, come up with a static code analysis in which you describe the current state of the code base. Think about the steps we took in exercise 1 . After you have done this, you should be able to identify and describe certain code smells . Describe these smells (in somewhat detail, including the programming code) and make suggestions for improvements. All this should return in a small report of about five to ten pages (including images and code listings). You don't have to perform the refactoring \u2013 a description will suffice.","title":"Final assignment"},{"location":"exercise1.html","text":"Exercise 1: Static code analysis \u00b6 In this exercise we are going to look at the code delivered by a student. Download the code-basae using this link . Because of reasons of privacy and NDA's, we have changed the conde somewhat, so if you see any strange stuff that's probably because of that. Static code analysis is meant to be done without running or even compiling the code. It can be done using techniques as fgrep , but also just by glancing over the code, opening files and see how they interact with each other. Different, very professional techniques exist for these kind of jobs, but for this small code-base doing stuff by hand will suffice. In this session, we will divide the group in four to five different sub-groups. Each group will work on one the following assignments for about an hour. After that, they will present their finding is a small pitch : no powerpoint or other presentation is required, just talk about what you have found out. Exercise 1: the factory \u00b6 The application can parse the report in two different formats as a pdf file or as a text file. In the future it could be possible that the hospitals share the information in another file format than the two which are now implemented. To extend the functionality in the feature, a parent class HsmrParser was created which must be extend in the implementations of the specific parsers. At the moment, two different parsers are realised, but more can be added in the future. A factory was created to get a instance of the parser based on the parser types which are defined as constants in the file parserTypes.py file. What is a factory? Does the implementation of the factory method follow the Interface Segregation Principle ? Exercise 2: Single reponsibility \u00b6 The application uses the CCS classifiation to extract the information from the HSMR reports. The application uses a csv file with the ccs index and the corresponded Dutch description. This information is provided by the CBS as Microsoft Office Excel file. The nessesary data was extracted and saved as CSV file. Review the python files starting with Ccs. Are those files adhering to he single-responsibility principle: \"Every class should have only one responsibility\u201d? Exercise 3: The base classes \u00b6 In the code several base classes are used. Can you find examples of the Liskov substitution principle : \"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\" Explain your answer 4. The local settings object \u00b6 A settings file was used inside the application to store the settings which can be changed over time or is user specific. For instance, the path to a temp directory is saved inside the settings file because they will be different between users. Also, specific table names of the HSMR report, API URLs, API headers are saved in this file because they can change and must be easily assessable. The Settings object is implemented as Singleton object inside the application to prevent multiple instances of the same class. It also prevents multiple unnecessary parsing of the settings file and eventually different settings when the settings are manually changed during runtime of the program. Search for the Settings class. What makes this class a singleton object and is a singleton object SOLID? The hospital types codes are stored in a python module hospital_types.py . Is this a logical solution? Is there an alternative solution for these kind of local settings and parameters? Exercise 5. Class diagram \u00b6 Draw the class diagram for this program.","title":"Exercise 1: Static code analysis"},{"location":"exercise1.html#exercise-1-static-code-analysis","text":"In this exercise we are going to look at the code delivered by a student. Download the code-basae using this link . Because of reasons of privacy and NDA's, we have changed the conde somewhat, so if you see any strange stuff that's probably because of that. Static code analysis is meant to be done without running or even compiling the code. It can be done using techniques as fgrep , but also just by glancing over the code, opening files and see how they interact with each other. Different, very professional techniques exist for these kind of jobs, but for this small code-base doing stuff by hand will suffice. In this session, we will divide the group in four to five different sub-groups. Each group will work on one the following assignments for about an hour. After that, they will present their finding is a small pitch : no powerpoint or other presentation is required, just talk about what you have found out.","title":"Exercise 1: Static code analysis"},{"location":"exercise1.html#exercise-1-the-factory","text":"The application can parse the report in two different formats as a pdf file or as a text file. In the future it could be possible that the hospitals share the information in another file format than the two which are now implemented. To extend the functionality in the feature, a parent class HsmrParser was created which must be extend in the implementations of the specific parsers. At the moment, two different parsers are realised, but more can be added in the future. A factory was created to get a instance of the parser based on the parser types which are defined as constants in the file parserTypes.py file. What is a factory? Does the implementation of the factory method follow the Interface Segregation Principle ?","title":"Exercise 1: the factory"},{"location":"exercise1.html#exercise-2-single-reponsibility","text":"The application uses the CCS classifiation to extract the information from the HSMR reports. The application uses a csv file with the ccs index and the corresponded Dutch description. This information is provided by the CBS as Microsoft Office Excel file. The nessesary data was extracted and saved as CSV file. Review the python files starting with Ccs. Are those files adhering to he single-responsibility principle: \"Every class should have only one responsibility\u201d?","title":"Exercise 2: Single reponsibility"},{"location":"exercise1.html#exercise-3-the-base-classes","text":"In the code several base classes are used. Can you find examples of the Liskov substitution principle : \"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\" Explain your answer","title":"Exercise 3: The base classes"},{"location":"exercise1.html#4-the-local-settings-object","text":"A settings file was used inside the application to store the settings which can be changed over time or is user specific. For instance, the path to a temp directory is saved inside the settings file because they will be different between users. Also, specific table names of the HSMR report, API URLs, API headers are saved in this file because they can change and must be easily assessable. The Settings object is implemented as Singleton object inside the application to prevent multiple instances of the same class. It also prevents multiple unnecessary parsing of the settings file and eventually different settings when the settings are manually changed during runtime of the program. Search for the Settings class. What makes this class a singleton object and is a singleton object SOLID? The hospital types codes are stored in a python module hospital_types.py . Is this a logical solution? Is there an alternative solution for these kind of local settings and parameters?","title":"4. The local settings object"},{"location":"exercise1.html#exercise-5-class-diagram","text":"Draw the class diagram for this program.","title":"Exercise 5. Class diagram"},{"location":"exercise2.html","text":"Exercise 2: Classes and instances \u00b6 Introduction \u00b6 Photosynthesis is the process by which plants and certain algae convert light energy into chemical energy that can be stored and used to drive the organism's activities. Though different varieties of photosynthesis exist, the overall equation for the type that occurs in plants is as follows: \\(6CO_2 + 6H_2O -> C_6H_{12}O_6 + 6O_2 + energy\\) In this exercise, we are going to realise a very simple model of this process. Assignment 1: the Atom class \u00b6 1a. Create a class Atom that is a representation of any atom in the periodic table. Make sure that when a concrete atom is instantiated, it is given its symbol, its atomic number and the number of neutrons in the core. Store those parameters in the created object. 1b. Create a method proton_number that returns the number of protons in the nucleus; make another method mass_number that returns the sum of protons and neutrons in the nucleus. Isotopes are types of atoms that have the same number of atomic number but a different number of neutrons in the core. So, e.g. 'normal' hydrogen has 1 proton and 1 neutron, but it also comes in the form of deuterium (1 proton and 2 neutrons) or even tritium (1 proton and 3 neutrons). 1c. Create a method isotope in the class Atom . When this method is called, the normal number of neutrons must be replaced by whatever number is provided to this method. 1d. We define an atom A to be less than another atom B if their proton number is the same (i.e. it is the same element) but the mass number of A is less than the mass number of B. Implement the methods that checks whether two isotopes of the same element are equal to each other, or less than or greater than each other. Raise an exception when the check called with different type of elements. You can use the code below to test your implementation. protium = Atom ( 'H' , 1 , 1 ) deuterium = Atom ( 'H' , 1 , 2 ) oxygen = Atom ( 'O' , 8 , 8 ) tritium = Atom ( 'H' , 1 , 2 ) tritium . isotope ( 3 ) assert tritium . neutrons == 3 assert tritium . mass_number () == 4 assert protium < deuterium assert deuterium <= tritium assert tritium >= protium print ( oxygen > tritium ) # <-- this should raise an Exception Assignment 2: the Molecule class \u00b6 A molecule is a neutral group of two or more atoms. 2a. Create the class Molecule . When creating an instance of this class, a list of tuples of two values (a pair ) is given. The first element of this pair is the Atom-object, the second element is the number of atoms of that type that is put into the molecule. Thus, the following code snippet creates a water-molecule: hydrogen = Atom ( 'H' , 1 , 1 ) oxygen = Atom ( 'O' , 8 , 8 ) water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) 2b. Make sure that when we print individual molecules, we get somehing resembling the correct chemical formula (you don't have to take the exact protocol into account). So, e.g. print (water) would render H2O . Make sure that the number 1 is omitted in the representation. 2c In our small implementation, molecules that are created can never change (they are immutable ). However, we can add two molecules together in order to create a new molecule. Implement this method in the class Molecule . Creating molecules this way is, of course, not really possible. However, because of educational reasons we pretend that this is an ok way to work. You can use the code below to test your implementation: hydrogen = Atom ( 'H' , 1 , 1 ) carbon = Atom ( 'C' , 6 , 6 ) oxygen = Atom ( 'O' , 8 , 8 ) water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) co2 = Molecule ( [ ( carbon , 1 ), ( oxygen , 2 ) ]) print ( water ) # H2O print ( co2 ) # CO2 print ( water + co2 ) # H2OCO2 Assignment 3: The Chloroplast class \u00b6 As a final assignment, we are going to make a (very, very) simplified version of the photosynthesis process; basically, we are only going to implement the formula stated above. 3a. Create the class Chloroplast . When creating objects of this type, make sure two fields water and co2 are initialised at value 0 . 3b. Implement the following functionality: make a methode add_molecule in which we can add water or carbondioxyde molecules. When we add either of them, the corresponding field is incrementend by one. When we add something else than water of carbondioxyde, a ValueError is raised, but the program continues to function. If nothing else happens, this method returns an empty list 3c. When we have added a total of 6 CO2-molecules and 12 H2O-molecules, we start of the photosyntheses. We decrease the fields water and co2 with 6 and 12 respectively and create three new molecules: C6H12O6 , O2 and H2O . In this case, the method returns a list of tuples: 1 molecule of sugar, 6 molecules of oxygen and 6 molecules of water (as per the general formula stated above). 3d. Make sure thwat when we print this instance of chloroplast, we get an idea of how many molecules of water and co2 are already stored in it. You can use the following script to check your implementation water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) co2 = Molecule ( [ ( carbon , 1 ), ( oxygen , 2 ) ]) demo = Chloroplast () els = [ water , co2 ] while ( True ): print ( ' \\n What molecule would you like to add?' ) print ( '[1] Water' ) print ( '[2] carbondioxyde' ) print ( 'Please enter your choice: ' , end = '' ) try : choice = int ( input ()) res = demo . add_molecule ( els [ choice - 1 ]) if ( len ( res ) == 0 ): print ( demo ) else : print ( ' \\n === Photosynthesis!' ) print ( res ) print ( demo ) except Exception : print ( ' \\n === That is not a valid choice.' ) Wrap up \u00b6 Make sure your code follows the SOLID principles. Do you see any refactoring-possibilities? Did you use constants where possible? Have you identified all the stuff that stayed the same and seperated that from all the stuff that changed...?","title":"Exercise 2: Classes and instances"},{"location":"exercise2.html#exercise-2-classes-and-instances","text":"","title":"Exercise 2: Classes and instances"},{"location":"exercise2.html#introduction","text":"Photosynthesis is the process by which plants and certain algae convert light energy into chemical energy that can be stored and used to drive the organism's activities. Though different varieties of photosynthesis exist, the overall equation for the type that occurs in plants is as follows: \\(6CO_2 + 6H_2O -> C_6H_{12}O_6 + 6O_2 + energy\\) In this exercise, we are going to realise a very simple model of this process.","title":"Introduction"},{"location":"exercise2.html#assignment-1-the-atom-class","text":"1a. Create a class Atom that is a representation of any atom in the periodic table. Make sure that when a concrete atom is instantiated, it is given its symbol, its atomic number and the number of neutrons in the core. Store those parameters in the created object. 1b. Create a method proton_number that returns the number of protons in the nucleus; make another method mass_number that returns the sum of protons and neutrons in the nucleus. Isotopes are types of atoms that have the same number of atomic number but a different number of neutrons in the core. So, e.g. 'normal' hydrogen has 1 proton and 1 neutron, but it also comes in the form of deuterium (1 proton and 2 neutrons) or even tritium (1 proton and 3 neutrons). 1c. Create a method isotope in the class Atom . When this method is called, the normal number of neutrons must be replaced by whatever number is provided to this method. 1d. We define an atom A to be less than another atom B if their proton number is the same (i.e. it is the same element) but the mass number of A is less than the mass number of B. Implement the methods that checks whether two isotopes of the same element are equal to each other, or less than or greater than each other. Raise an exception when the check called with different type of elements. You can use the code below to test your implementation. protium = Atom ( 'H' , 1 , 1 ) deuterium = Atom ( 'H' , 1 , 2 ) oxygen = Atom ( 'O' , 8 , 8 ) tritium = Atom ( 'H' , 1 , 2 ) tritium . isotope ( 3 ) assert tritium . neutrons == 3 assert tritium . mass_number () == 4 assert protium < deuterium assert deuterium <= tritium assert tritium >= protium print ( oxygen > tritium ) # <-- this should raise an Exception","title":"Assignment 1: the Atom class"},{"location":"exercise2.html#assignment-2-the-molecule-class","text":"A molecule is a neutral group of two or more atoms. 2a. Create the class Molecule . When creating an instance of this class, a list of tuples of two values (a pair ) is given. The first element of this pair is the Atom-object, the second element is the number of atoms of that type that is put into the molecule. Thus, the following code snippet creates a water-molecule: hydrogen = Atom ( 'H' , 1 , 1 ) oxygen = Atom ( 'O' , 8 , 8 ) water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) 2b. Make sure that when we print individual molecules, we get somehing resembling the correct chemical formula (you don't have to take the exact protocol into account). So, e.g. print (water) would render H2O . Make sure that the number 1 is omitted in the representation. 2c In our small implementation, molecules that are created can never change (they are immutable ). However, we can add two molecules together in order to create a new molecule. Implement this method in the class Molecule . Creating molecules this way is, of course, not really possible. However, because of educational reasons we pretend that this is an ok way to work. You can use the code below to test your implementation: hydrogen = Atom ( 'H' , 1 , 1 ) carbon = Atom ( 'C' , 6 , 6 ) oxygen = Atom ( 'O' , 8 , 8 ) water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) co2 = Molecule ( [ ( carbon , 1 ), ( oxygen , 2 ) ]) print ( water ) # H2O print ( co2 ) # CO2 print ( water + co2 ) # H2OCO2","title":"Assignment 2: the Molecule class"},{"location":"exercise2.html#assignment-3-the-chloroplast-class","text":"As a final assignment, we are going to make a (very, very) simplified version of the photosynthesis process; basically, we are only going to implement the formula stated above. 3a. Create the class Chloroplast . When creating objects of this type, make sure two fields water and co2 are initialised at value 0 . 3b. Implement the following functionality: make a methode add_molecule in which we can add water or carbondioxyde molecules. When we add either of them, the corresponding field is incrementend by one. When we add something else than water of carbondioxyde, a ValueError is raised, but the program continues to function. If nothing else happens, this method returns an empty list 3c. When we have added a total of 6 CO2-molecules and 12 H2O-molecules, we start of the photosyntheses. We decrease the fields water and co2 with 6 and 12 respectively and create three new molecules: C6H12O6 , O2 and H2O . In this case, the method returns a list of tuples: 1 molecule of sugar, 6 molecules of oxygen and 6 molecules of water (as per the general formula stated above). 3d. Make sure thwat when we print this instance of chloroplast, we get an idea of how many molecules of water and co2 are already stored in it. You can use the following script to check your implementation water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) co2 = Molecule ( [ ( carbon , 1 ), ( oxygen , 2 ) ]) demo = Chloroplast () els = [ water , co2 ] while ( True ): print ( ' \\n What molecule would you like to add?' ) print ( '[1] Water' ) print ( '[2] carbondioxyde' ) print ( 'Please enter your choice: ' , end = '' ) try : choice = int ( input ()) res = demo . add_molecule ( els [ choice - 1 ]) if ( len ( res ) == 0 ): print ( demo ) else : print ( ' \\n === Photosynthesis!' ) print ( res ) print ( demo ) except Exception : print ( ' \\n === That is not a valid choice.' )","title":"Assignment 3: The Chloroplast class"},{"location":"exercise2.html#wrap-up","text":"Make sure your code follows the SOLID principles. Do you see any refactoring-possibilities? Did you use constants where possible? Have you identified all the stuff that stayed the same and seperated that from all the stuff that changed...?","title":"Wrap up"},{"location":"exercise3.html","text":"Exercise 3: Multiple Class Interaction \u00b6 In this exercise, we will be building a relatively complexe system that consists of serveral classes that need to coordinate certain events. In the process, we introduce the concept of asynchronicity, generators, parallellism and message queues. The central idea is that we have some data that needs to be harvested, transformed and distributed. We build this application in several more or less independent steps, in order to bring the idea home that seperation and compartmentalization are good things. Step 1: Producing data \u00b6 Download the file dSST.csv and study its contents. This is a comma-seperated datafile consisting of the average monthly global temperature anomalies between the years 1880-2021. These temperatures are based on the GISS Surface Temperature Analysis (GISTEMP v4), an estimate of global surface temperature change. Anomalies are defined relative to a base period of 1951-1980. 1a: from csv to json \u00b6 We want this data to be made available in json instead of csv. The big difference between these two date formats is that the first line of a csv-file contains all the properties ( keys ) of the data, while json needs to have these properties repeated. Have a look at the following example: key1,key2 1880,3.14 1881,2.87 which in json would be [{ \"key1\" : 1880 , \"key2\" : 3.14 },{ \"key1\" : 1881 , \"key2\" : 2.87 }] Create a class CsvConverter which does exactly this. Make sure that when you create an instance of this class, the header (first line) of a csv-file is added. Since this is usually just a string, make sure to split this line using str.split(',') in order to create a list of keys. Add a method csv_to_json() which receives a list of lines from a csv-file and returns this data as json. Again, since the lines are just strings, use split to transform each line into a list of values. Make sure that the amount of items in each line corresponds to the number of elements in the header that you stored in the object (make us of assert and issue a nice warning when the numbers don't match). Use the following code as an example for your implementation: >>> keys = 'a,b,c,d' >>> vals = '3,2,1,5' >>> dict ( zip ( keys . split ( ',' ), vals . split ( ',' ))) { 'a' : '3' , 'b' : '2' , 'c' : '1' , 'd' : '5' } >>> You may need to use json.dumps() in your method to make sure that the returned value is indeed valid json (past it into jsonparser.org when in doubt). 1b. getting the data \u00b6 Create a class Reader which gets the location of a csv-file in its constructor (you might want to default this to our dSSST.csv ). Also in the constructor, create an instance of the CvsConcerter and store that in the object's memory space. Reader -objects will read the given csv-files in strides of a certain amount of lines. In order to do this, you will need to do some bookkeeping within the object itself: you will need to store both the number of lines that are read in one go and also a pointer to the current line in the file. Add a method get_lines() to the Reader -class. In this method, the next stride of lines is returned as json. You can use linecache to read certain lines of the data-file. So, given that the first line of our csv-file contains its keys, a flow could be like this (output omitted for readability): red = Reader ( 'dSST.csv' ) red . get_lines () #returns lines 2-6 as json reg . get_lines () #returns lines 7-11 as json reg . get_lines () #returns lines 12-16 as json If there are no more lines in the data-file, the method get_lines() needs to return an empty string. Step 2: Consuming the data \u00b6 We are going to create two classes, AverageYear and AverageMonth that make use of this temperature-data that is being provided by objects of the Reader -class. There are, of course, several ways in which you can make these Reader -objects available in the consuming classes: we can create a new Reader -object when initializing our consumer, or we can make one Reader -object and give that object to the initializer of the consumers. What do you think are the pros and cons of both approaches? The first consuming class will show the average temperature anomaly for the complete set of five years that our Reader is returning. the second class needs to show the average montly anomaly for the same five years. Please note that the number of columns is larger than the number of months within the year (the last few columns are some kind of special meteorological averages), so be sure to take the right data. Of course, in both classes you can make use of pandas, numpy, matplotlib and all kind of libraries you are used to in order to make some sort of visualisation. Within both classes, use consecutive calls to get_lines() in order to get the next stride of lines from this data-class. Stop calling this method whenever this method returns an empty string. You don't need to make an incremental plot with each new call to get_lines() (thought that would be a nice addition): it is sufficient when you repaint your visualisation every time new data gets returned. In the end, the architecture would look as follows: There are several issues with this architecture, regardsless of the way in which you provided the consuming classes with the Reader -objects. In the following step, we are going to decouple these classes in order to create a more robust and versatile system. Step 3: The observer pattern \u00b6 During the theoretical part, the observer pattern was briefly described. For easy reference, the sequence diagram that was shown is repeated here: In this step, we are going to refactor the classes you've created in step 3 in order to realise this design pattern. 3a: Extending the reader \u00b6 Create two methods in the Reader -class, add_observer() and remove_observer() so that we can add and remove observers. Make sure that when we create a new instance of the Reader , you create an empty set within the memory-space of the Reader . A call to the first method should add the given observer to this list, a call to the second call will (drumm-roll) remove the observer from the list if it is present. If the observer is not present in the list, make sure that nothing happens (removing a non-existent observer from this list is not a reason the crash a system) Next, add a method to notify_observers() to Reader . When called, this method needs to iterate over all the registered observers and call update() on each of them. Now, change the Reader so that the next five lines (the stride ) are produced every five seconds (you can make use of time.sleep(5) in order to accomplish this) and every time new data is read a call to notify_observers() is made. 3b: Extending the consumers \u00b6 Now we need to change the two consumers we created in step 2. Instead of making them responsible for the call to next_lines() , we just let them react to the updates of the Reader -class. Whenever this class has new data available, it will run notify_observers() which in turn will call update() on the observer. Make sure that whenever the update -method is called from the producer, the same visualisation that you made in step 2 is rendered. Please refer to the listing below to get an idea of the infrastructure that is required: prod = Reader ( 'dSST.csv' ) cons1 = AverageYear () cons2 = AverageMonth () prod . register_observer ( cons1 ) prod . register_observer ( cons2 ) If all goes well, some of the problems we encountered earlier are more or less solved. However, this architecture has some problems of its own. Can you see where this goes wrong and how you can solve them?","title":"Exercise 3: Multiple Class Interaction"},{"location":"exercise3.html#exercise-3-multiple-class-interaction","text":"In this exercise, we will be building a relatively complexe system that consists of serveral classes that need to coordinate certain events. In the process, we introduce the concept of asynchronicity, generators, parallellism and message queues. The central idea is that we have some data that needs to be harvested, transformed and distributed. We build this application in several more or less independent steps, in order to bring the idea home that seperation and compartmentalization are good things.","title":"Exercise 3: Multiple Class Interaction"},{"location":"exercise3.html#step-1-producing-data","text":"Download the file dSST.csv and study its contents. This is a comma-seperated datafile consisting of the average monthly global temperature anomalies between the years 1880-2021. These temperatures are based on the GISS Surface Temperature Analysis (GISTEMP v4), an estimate of global surface temperature change. Anomalies are defined relative to a base period of 1951-1980.","title":"Step 1: Producing data"},{"location":"exercise3.html#1a-from-csv-to-json","text":"We want this data to be made available in json instead of csv. The big difference between these two date formats is that the first line of a csv-file contains all the properties ( keys ) of the data, while json needs to have these properties repeated. Have a look at the following example: key1,key2 1880,3.14 1881,2.87 which in json would be [{ \"key1\" : 1880 , \"key2\" : 3.14 },{ \"key1\" : 1881 , \"key2\" : 2.87 }] Create a class CsvConverter which does exactly this. Make sure that when you create an instance of this class, the header (first line) of a csv-file is added. Since this is usually just a string, make sure to split this line using str.split(',') in order to create a list of keys. Add a method csv_to_json() which receives a list of lines from a csv-file and returns this data as json. Again, since the lines are just strings, use split to transform each line into a list of values. Make sure that the amount of items in each line corresponds to the number of elements in the header that you stored in the object (make us of assert and issue a nice warning when the numbers don't match). Use the following code as an example for your implementation: >>> keys = 'a,b,c,d' >>> vals = '3,2,1,5' >>> dict ( zip ( keys . split ( ',' ), vals . split ( ',' ))) { 'a' : '3' , 'b' : '2' , 'c' : '1' , 'd' : '5' } >>> You may need to use json.dumps() in your method to make sure that the returned value is indeed valid json (past it into jsonparser.org when in doubt).","title":"1a: from csv to json"},{"location":"exercise3.html#1b-getting-the-data","text":"Create a class Reader which gets the location of a csv-file in its constructor (you might want to default this to our dSSST.csv ). Also in the constructor, create an instance of the CvsConcerter and store that in the object's memory space. Reader -objects will read the given csv-files in strides of a certain amount of lines. In order to do this, you will need to do some bookkeeping within the object itself: you will need to store both the number of lines that are read in one go and also a pointer to the current line in the file. Add a method get_lines() to the Reader -class. In this method, the next stride of lines is returned as json. You can use linecache to read certain lines of the data-file. So, given that the first line of our csv-file contains its keys, a flow could be like this (output omitted for readability): red = Reader ( 'dSST.csv' ) red . get_lines () #returns lines 2-6 as json reg . get_lines () #returns lines 7-11 as json reg . get_lines () #returns lines 12-16 as json If there are no more lines in the data-file, the method get_lines() needs to return an empty string.","title":"1b. getting the data"},{"location":"exercise3.html#step-2-consuming-the-data","text":"We are going to create two classes, AverageYear and AverageMonth that make use of this temperature-data that is being provided by objects of the Reader -class. There are, of course, several ways in which you can make these Reader -objects available in the consuming classes: we can create a new Reader -object when initializing our consumer, or we can make one Reader -object and give that object to the initializer of the consumers. What do you think are the pros and cons of both approaches? The first consuming class will show the average temperature anomaly for the complete set of five years that our Reader is returning. the second class needs to show the average montly anomaly for the same five years. Please note that the number of columns is larger than the number of months within the year (the last few columns are some kind of special meteorological averages), so be sure to take the right data. Of course, in both classes you can make use of pandas, numpy, matplotlib and all kind of libraries you are used to in order to make some sort of visualisation. Within both classes, use consecutive calls to get_lines() in order to get the next stride of lines from this data-class. Stop calling this method whenever this method returns an empty string. You don't need to make an incremental plot with each new call to get_lines() (thought that would be a nice addition): it is sufficient when you repaint your visualisation every time new data gets returned. In the end, the architecture would look as follows: There are several issues with this architecture, regardsless of the way in which you provided the consuming classes with the Reader -objects. In the following step, we are going to decouple these classes in order to create a more robust and versatile system.","title":"Step 2: Consuming the data"},{"location":"exercise3.html#step-3-the-observer-pattern","text":"During the theoretical part, the observer pattern was briefly described. For easy reference, the sequence diagram that was shown is repeated here: In this step, we are going to refactor the classes you've created in step 3 in order to realise this design pattern.","title":"Step 3: The observer pattern"},{"location":"exercise3.html#3a-extending-the-reader","text":"Create two methods in the Reader -class, add_observer() and remove_observer() so that we can add and remove observers. Make sure that when we create a new instance of the Reader , you create an empty set within the memory-space of the Reader . A call to the first method should add the given observer to this list, a call to the second call will (drumm-roll) remove the observer from the list if it is present. If the observer is not present in the list, make sure that nothing happens (removing a non-existent observer from this list is not a reason the crash a system) Next, add a method to notify_observers() to Reader . When called, this method needs to iterate over all the registered observers and call update() on each of them. Now, change the Reader so that the next five lines (the stride ) are produced every five seconds (you can make use of time.sleep(5) in order to accomplish this) and every time new data is read a call to notify_observers() is made.","title":"3a: Extending the reader"},{"location":"exercise3.html#3b-extending-the-consumers","text":"Now we need to change the two consumers we created in step 2. Instead of making them responsible for the call to next_lines() , we just let them react to the updates of the Reader -class. Whenever this class has new data available, it will run notify_observers() which in turn will call update() on the observer. Make sure that whenever the update -method is called from the producer, the same visualisation that you made in step 2 is rendered. Please refer to the listing below to get an idea of the infrastructure that is required: prod = Reader ( 'dSST.csv' ) cons1 = AverageYear () cons2 = AverageMonth () prod . register_observer ( cons1 ) prod . register_observer ( cons2 ) If all goes well, some of the problems we encountered earlier are more or less solved. However, this architecture has some problems of its own. Can you see where this goes wrong and how you can solve them?","title":"3b: Extending the consumers"},{"location":"exercise4.html","text":"Exercise 4: Test Driven Development \u00b6 Introduction \u00b6 In this small exercise, we are going to develop a specific class using the principles of test driven development (TDD). In short this means that you first write your tests and after that you write the code that makes your test pass. And this in an cyclic manner \u2013 the so-called Red-Green-Refactor cycle . 1: basic setup \u00b6 Of course, you could populate your production code with all sorts of assert -statements in order to keep a check on its proper workings. However, keeping all your tests in one place has several advantages: it keeps your code nicely seperated from the tests it allows you to run tests independently you can make use of fixtures throughout all your tests it simplyfies the running of tests In these exercises, we are going to make use of the package pytest , so we need to install that first. After that, we need to build our application structure for pytest to automatically find and run all the tests. We are first going to recreate the setup that was demonstrated during the lecture; after that, you will write your code in the bin directory and your tests in the (drum-roll) tests -directory. ( venv ) $ python - m pip install pytest Now create the following structure: \u251c\u2500\u2500 bin \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 summing.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 conftest.py \u251c\u2500\u2500 pytest.ini \u2514\u2500\u2500 test_sum \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_summing.py Create two empty functions in bin/summing.py (just declare the function signatures and give them pass ): simple_sum and multiple_sum . Provide the file test_summing.py with tests for these functions. Use the following lines of code to tests those functions: def test_sum (): assert simple_sum ( 3 , 3 ) == 6 , 'should be 6' def test_another_sum (): assert multiple_sum ( 1 , 2 , 3 , 4 , 5 ) == 15 If all goes well, and you run python -m pytest tests , you will see that the tests fail, which is quite understandable, as we have not given any implementation to the methods yet. The function simple_sum needs to accept exactly two parameters and returns the sum of those two. The second method multiple_sum needs to accept any number of parameters and returns the complete sum of all those parameters. Implement these methods and make sure that the tests will succeed when you are finished. 2: DNA \u00b6 In this second exercise, we create a class DNA in a test-driven manner. That means that we first create the test-cases and after that the implementing code. Out DNA -class will be relatively simple; it needs to be able to fulfill the following five functional requirements: When creating an object of type DNA , a string of nucleotides must be provided. This string should only contain the characters A , C , T , G and the total length should be a multiple of three. When an object of DNA is printed, it should print out the complete string of DNA that is stored in its memory. It should be possible to add a triplet of A , C , T , or G to the existing dna-string. One can iterate over objects of the class DNA . Within every iteration, the next triplet of nucleotides should be returned, until the complete dna-string is consumed. Objects of the class DNA should be immutable. See the code listing below to get an idea of the workings of this class In [ 1 ]: from bin.dna import DNA In [ 2 ]: dna = DNA ( 'ACTGACTGACTG' ) In [ 3 ]: dna Out [ 3 ]: ACTGACTGACTG In [ 4 ]: dna = dna + 'ACG' In [ 5 ]: dna Out [ 5 ]: ACTGACTGACTGACG In [ 6 ]: for triplet in dna : ... : print ( triplet ) ... : ACT GAC TGA CTG In [ 7 ]: First, create tests for all of those requirements. It would be best to create so-called positive tests (that check whether the class works as expected with correct input), but also negative tests (to show that things break when provided wrong input). Implements the tests in your test-class and commit your code to github when you're done. The last step of this exercise will be given orally when everybody is done. 3: Discussion \u00b6 Think about the project that you did last semester. How would you use unit testing and TDD to test parts of your code? What critical parts do you think should be developed and tested in this manner? How do you see these technologies in your current project?","title":"Exercise 4: Test Driven Development"},{"location":"exercise4.html#exercise-4-test-driven-development","text":"","title":"Exercise 4: Test Driven Development"},{"location":"exercise4.html#introduction","text":"In this small exercise, we are going to develop a specific class using the principles of test driven development (TDD). In short this means that you first write your tests and after that you write the code that makes your test pass. And this in an cyclic manner \u2013 the so-called Red-Green-Refactor cycle .","title":"Introduction"},{"location":"exercise4.html#1-basic-setup","text":"Of course, you could populate your production code with all sorts of assert -statements in order to keep a check on its proper workings. However, keeping all your tests in one place has several advantages: it keeps your code nicely seperated from the tests it allows you to run tests independently you can make use of fixtures throughout all your tests it simplyfies the running of tests In these exercises, we are going to make use of the package pytest , so we need to install that first. After that, we need to build our application structure for pytest to automatically find and run all the tests. We are first going to recreate the setup that was demonstrated during the lecture; after that, you will write your code in the bin directory and your tests in the (drum-roll) tests -directory. ( venv ) $ python - m pip install pytest Now create the following structure: \u251c\u2500\u2500 bin \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 summing.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 conftest.py \u251c\u2500\u2500 pytest.ini \u2514\u2500\u2500 test_sum \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_summing.py Create two empty functions in bin/summing.py (just declare the function signatures and give them pass ): simple_sum and multiple_sum . Provide the file test_summing.py with tests for these functions. Use the following lines of code to tests those functions: def test_sum (): assert simple_sum ( 3 , 3 ) == 6 , 'should be 6' def test_another_sum (): assert multiple_sum ( 1 , 2 , 3 , 4 , 5 ) == 15 If all goes well, and you run python -m pytest tests , you will see that the tests fail, which is quite understandable, as we have not given any implementation to the methods yet. The function simple_sum needs to accept exactly two parameters and returns the sum of those two. The second method multiple_sum needs to accept any number of parameters and returns the complete sum of all those parameters. Implement these methods and make sure that the tests will succeed when you are finished.","title":"1: basic setup"},{"location":"exercise4.html#2-dna","text":"In this second exercise, we create a class DNA in a test-driven manner. That means that we first create the test-cases and after that the implementing code. Out DNA -class will be relatively simple; it needs to be able to fulfill the following five functional requirements: When creating an object of type DNA , a string of nucleotides must be provided. This string should only contain the characters A , C , T , G and the total length should be a multiple of three. When an object of DNA is printed, it should print out the complete string of DNA that is stored in its memory. It should be possible to add a triplet of A , C , T , or G to the existing dna-string. One can iterate over objects of the class DNA . Within every iteration, the next triplet of nucleotides should be returned, until the complete dna-string is consumed. Objects of the class DNA should be immutable. See the code listing below to get an idea of the workings of this class In [ 1 ]: from bin.dna import DNA In [ 2 ]: dna = DNA ( 'ACTGACTGACTG' ) In [ 3 ]: dna Out [ 3 ]: ACTGACTGACTG In [ 4 ]: dna = dna + 'ACG' In [ 5 ]: dna Out [ 5 ]: ACTGACTGACTGACG In [ 6 ]: for triplet in dna : ... : print ( triplet ) ... : ACT GAC TGA CTG In [ 7 ]: First, create tests for all of those requirements. It would be best to create so-called positive tests (that check whether the class works as expected with correct input), but also negative tests (to show that things break when provided wrong input). Implements the tests in your test-class and commit your code to github when you're done. The last step of this exercise will be given orally when everybody is done.","title":"2: DNA"},{"location":"exercise4.html#3-discussion","text":"Think about the project that you did last semester. How would you use unit testing and TDD to test parts of your code? What critical parts do you think should be developed and tested in this manner? How do you see these technologies in your current project?","title":"3: Discussion"},{"location":"exercise5.html","text":"Exercise 5: Dependency Injection \u00b6 In this exercise we are going to make use of the Reader and the CsvConverter that we created in exercise 3 . You can use your own implementation, or use this example realisation . We will change this class into a service and inject that into a client-class. Step 1: changing the Reader \u00b6 In the third exercise, we created the method get_lines() and an internal pointer to have the Reader read and return the next stride of lines from the csv-file. Change this class into a generator, so that we can either iterate over it, or just call next() . Remove any implementations that you have created to implement the observer pattern. Check the code below to get an idea of the required workings: In [ 1 ]: from reader import Reader In [ 2 ]: reader = Reader ( 'dSST.csv' , 5 ) In [ 3 ]: for l in reader : ... : print ( len ( l )) ... : 5 5 # (about 28 times 5) Step 2: creating the client \u00b6 Now that we have created the generator, we are going to make a client called Processor that makes use of it in the form of a service. Have a look a the image below: In this case, the composition root will be where script you are going to use to construct the object graph. The Reader -class will be the dependecy ( ProductService in the image), while Processor is the consumer ( HomeController in the image). Of course, you have to make use of the DI-pattern. The Processor has basically the same functionality as one of the observers of week 3. Only this time it is requires to have some (very basic) interaction with a user. The user can ask for either five time a general average temperature (the average temperature of all the five years in the stride, horizontally so to say) of the average temperature of all the months over these five years (vertically). Or the user can as for the next stride of data. See the example below: ******************** Welcome to the awesome data processor. ******************** Please select one of the following: 1 . get horizontal data 2 . get vertical data 3 . get next stride of data 9 . quit and exit Please enter your selection: 1 horizontal data goes here { 'Jan' : -0.198, 'Feb' : -0.148, 'Mar' : -0.13, 'Apr' : -0.216, 'May' : -0.202, 'Jun' : -0.244, 'Jul' : -0.168, 'Aug' : -0.158, 'Sep' : -0.204, 'Oct' : -0.204, 'Nov' : -0.222, 'Dec' : -0.186 } Please select one of the following: 1 . get horizontal data 2 . get vertical data 3 . get next stride of data 9 . quit and exit Please enter your selection: 9 bye! After this, make use of the composition root pattern within your application's entry point (the point where __name__=='__main__' returns True ) Discussion \u00b6 Do you see possibilities with this architecture within your own projects? How would you seperate the production of data from the consummation of it?","title":"Exercise 5: Dependency Injection"},{"location":"exercise5.html#exercise-5-dependency-injection","text":"In this exercise we are going to make use of the Reader and the CsvConverter that we created in exercise 3 . You can use your own implementation, or use this example realisation . We will change this class into a service and inject that into a client-class.","title":"Exercise 5: Dependency Injection"},{"location":"exercise5.html#step-1-changing-the-reader","text":"In the third exercise, we created the method get_lines() and an internal pointer to have the Reader read and return the next stride of lines from the csv-file. Change this class into a generator, so that we can either iterate over it, or just call next() . Remove any implementations that you have created to implement the observer pattern. Check the code below to get an idea of the required workings: In [ 1 ]: from reader import Reader In [ 2 ]: reader = Reader ( 'dSST.csv' , 5 ) In [ 3 ]: for l in reader : ... : print ( len ( l )) ... : 5 5 # (about 28 times 5)","title":"Step 1: changing the Reader"},{"location":"exercise5.html#step-2-creating-the-client","text":"Now that we have created the generator, we are going to make a client called Processor that makes use of it in the form of a service. Have a look a the image below: In this case, the composition root will be where script you are going to use to construct the object graph. The Reader -class will be the dependecy ( ProductService in the image), while Processor is the consumer ( HomeController in the image). Of course, you have to make use of the DI-pattern. The Processor has basically the same functionality as one of the observers of week 3. Only this time it is requires to have some (very basic) interaction with a user. The user can ask for either five time a general average temperature (the average temperature of all the five years in the stride, horizontally so to say) of the average temperature of all the months over these five years (vertically). Or the user can as for the next stride of data. See the example below: ******************** Welcome to the awesome data processor. ******************** Please select one of the following: 1 . get horizontal data 2 . get vertical data 3 . get next stride of data 9 . quit and exit Please enter your selection: 1 horizontal data goes here { 'Jan' : -0.198, 'Feb' : -0.148, 'Mar' : -0.13, 'Apr' : -0.216, 'May' : -0.202, 'Jun' : -0.244, 'Jul' : -0.168, 'Aug' : -0.158, 'Sep' : -0.204, 'Oct' : -0.204, 'Nov' : -0.222, 'Dec' : -0.186 } Please select one of the following: 1 . get horizontal data 2 . get vertical data 3 . get next stride of data 9 . quit and exit Please enter your selection: 9 bye! After this, make use of the composition root pattern within your application's entry point (the point where __name__=='__main__' returns True )","title":"Step 2: creating the client"},{"location":"exercise5.html#discussion","text":"Do you see possibilities with this architecture within your own projects? How would you seperate the production of data from the consummation of it?","title":"Discussion"}]}