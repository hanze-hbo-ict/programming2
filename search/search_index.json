{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Programming 2 \u00b6 These pages provide the materials, information, and assignments for the module Programming 2 for the Master Digital Science for Life Science. As its name suggests, this module is the follow-up of Programming 1 and it builds on the tools and techniques that were used in that first module. It aims to make students competent in designing parallel solutions for computational problems that aren\u2019t adequately solvable by a single computer. In order to do so, we first refresh the topics of Programming 1 , we look some more into object life-cycle and multiple class interaction. After this, we look into the Divide and Conquer and Map Reduce algorithms, which provides us the mindset of seperating our unit of work into several sub-problems, that can be easily distributed over several machines. In the second part of this module, we will actually perform this distribution. We will talk at some length about parallelism and network operations. After that we will use systems such as Spark of Dask to run several analyses of complex data sets. We end the module by looking at best practices from sofware engineering to make our own code base better. Schedule and links \u00b6 Part 1 weeknumber subject(s) 1 Refresh UML; SOLID; OO en design patterns 2 Classes and Objects; Constructors and Destructors; Object Lifecycle; Dunders 3 Multiple Class Interaction; modules 4 List Comprehensions; Generators; map-reduce 5 Unit of Work; Divide and Conquer algoritms Part 2 weeknumber subject(s) 1 Network Operations; POSIX stack 2 Parallellisation 3 Slurm and Dask 1 4 Slurm and Dask 2 5 MLOps 6 SE4ML 7 wrap up Assignment \u00b6 During the course, students will work individually on (more or less) weekly assignments. Every week, students are given time to work on these assignments and ask formative feedback. At the end of the term, the collection of all these elaborations will form a portfolio which will be graded. Should the portfolio be considered unsufficient, specific repair-assignments will be given.","title":"Programming 2"},{"location":"index.html#programming-2","text":"These pages provide the materials, information, and assignments for the module Programming 2 for the Master Digital Science for Life Science. As its name suggests, this module is the follow-up of Programming 1 and it builds on the tools and techniques that were used in that first module. It aims to make students competent in designing parallel solutions for computational problems that aren\u2019t adequately solvable by a single computer. In order to do so, we first refresh the topics of Programming 1 , we look some more into object life-cycle and multiple class interaction. After this, we look into the Divide and Conquer and Map Reduce algorithms, which provides us the mindset of seperating our unit of work into several sub-problems, that can be easily distributed over several machines. In the second part of this module, we will actually perform this distribution. We will talk at some length about parallelism and network operations. After that we will use systems such as Spark of Dask to run several analyses of complex data sets. We end the module by looking at best practices from sofware engineering to make our own code base better.","title":"Programming 2"},{"location":"index.html#schedule-and-links","text":"Part 1 weeknumber subject(s) 1 Refresh UML; SOLID; OO en design patterns 2 Classes and Objects; Constructors and Destructors; Object Lifecycle; Dunders 3 Multiple Class Interaction; modules 4 List Comprehensions; Generators; map-reduce 5 Unit of Work; Divide and Conquer algoritms Part 2 weeknumber subject(s) 1 Network Operations; POSIX stack 2 Parallellisation 3 Slurm and Dask 1 4 Slurm and Dask 2 5 MLOps 6 SE4ML 7 wrap up","title":"Schedule and links"},{"location":"index.html#assignment","text":"During the course, students will work individually on (more or less) weekly assignments. Every week, students are given time to work on these assignments and ask formative feedback. At the end of the term, the collection of all these elaborations will form a portfolio which will be graded. Should the portfolio be considered unsufficient, specific repair-assignments will be given.","title":"Assignment"},{"location":"week1.1.html","text":"Week 1.1: Static code analysis \u00b6 In this exercise we are going to look at the code delivered by a student. Download the code-basae using this link . Because of reasons of privacy and NDA's, we have changed the code somewhat, so if you see any strange stuff that's probably because of that. Static code analysis is meant to be done without running or even compiling the code. It can be done using techniques as fgrep , but also just by glancing over the code, opening files and see how they interact with each other. Different, very professional techniques exist for these kind of jobs, but for this small code-base doing stuff by hand will suffice. In this session, we will divide the group in four to five different sub-groups. Each group will work on one the following assignments for about an hour. After that, they will present their finding is a small pitch : no powerpoint or other presentation is required, just talk about what you have found out. Exercise 1: the factory \u00b6 The application can parse the report in two different formats as a pdf file or as a text file. In the future it could be possible that the hospitals share the information in another file format than the two which are now implemented. To extend the functionality in the feature, a parent class HsmrParser was created which must be extend in the implementations of the specific parsers. At the moment, two different parsers are realised, but more can be added in the future. A factory was created to get a instance of the parser based on the parser types which are defined as constants in the file parserTypes.py file. What is a factory? Does the implementation of the factory method follow the Interface Segregation Principle ? Exercise 2: Single reponsibility \u00b6 The application uses the CCS classifiation to extract the information from the HSMR reports. The application uses a csv file with the ccs index and the corresponded Dutch description. This information is provided by the CBS as Microsoft Office Excel file. The nessesary data was extracted and saved as CSV file. Review the python files starting with Ccs. Are those files adhering to he single-responsibility principle: \"Every class should have only one responsibility\u201d? Exercise 3: The base classes \u00b6 In the code several base classes are used. Can you find examples of the Liskov substitution principle : \"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\" Explain your answer 4. The local settings object \u00b6 A settings file was used inside the application to store the settings which can be changed over time or is user specific. For instance, the path to a temp directory is saved inside the settings file because they will be different between users. Also, specific table names of the HSMR report, API URLs, API headers are saved in this file because they can change and must be easily assessable. The Settings object is implemented as Singleton object inside the application to prevent multiple instances of the same class. It also prevents multiple unnecessary parsing of the settings file and eventually different settings when the settings are manually changed during runtime of the program. Search for the Settings class. What makes this class a singleton object and is a singleton object SOLID? The hospital types codes are stored in a python module hospital_types.py . Is this a logical solution? Is there an alternative solution for these kind of local settings and parameters? Exercise 5. Class diagram \u00b6 Draw the class diagram for this program.","title":"Week 1.1: Static code analysis"},{"location":"week1.1.html#week-11-static-code-analysis","text":"In this exercise we are going to look at the code delivered by a student. Download the code-basae using this link . Because of reasons of privacy and NDA's, we have changed the code somewhat, so if you see any strange stuff that's probably because of that. Static code analysis is meant to be done without running or even compiling the code. It can be done using techniques as fgrep , but also just by glancing over the code, opening files and see how they interact with each other. Different, very professional techniques exist for these kind of jobs, but for this small code-base doing stuff by hand will suffice. In this session, we will divide the group in four to five different sub-groups. Each group will work on one the following assignments for about an hour. After that, they will present their finding is a small pitch : no powerpoint or other presentation is required, just talk about what you have found out.","title":"Week 1.1: Static code analysis"},{"location":"week1.1.html#exercise-1-the-factory","text":"The application can parse the report in two different formats as a pdf file or as a text file. In the future it could be possible that the hospitals share the information in another file format than the two which are now implemented. To extend the functionality in the feature, a parent class HsmrParser was created which must be extend in the implementations of the specific parsers. At the moment, two different parsers are realised, but more can be added in the future. A factory was created to get a instance of the parser based on the parser types which are defined as constants in the file parserTypes.py file. What is a factory? Does the implementation of the factory method follow the Interface Segregation Principle ?","title":"Exercise 1: the factory"},{"location":"week1.1.html#exercise-2-single-reponsibility","text":"The application uses the CCS classifiation to extract the information from the HSMR reports. The application uses a csv file with the ccs index and the corresponded Dutch description. This information is provided by the CBS as Microsoft Office Excel file. The nessesary data was extracted and saved as CSV file. Review the python files starting with Ccs. Are those files adhering to he single-responsibility principle: \"Every class should have only one responsibility\u201d?","title":"Exercise 2: Single reponsibility"},{"location":"week1.1.html#exercise-3-the-base-classes","text":"In the code several base classes are used. Can you find examples of the Liskov substitution principle : \"Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.\" Explain your answer","title":"Exercise 3: The base classes"},{"location":"week1.1.html#4-the-local-settings-object","text":"A settings file was used inside the application to store the settings which can be changed over time or is user specific. For instance, the path to a temp directory is saved inside the settings file because they will be different between users. Also, specific table names of the HSMR report, API URLs, API headers are saved in this file because they can change and must be easily assessable. The Settings object is implemented as Singleton object inside the application to prevent multiple instances of the same class. It also prevents multiple unnecessary parsing of the settings file and eventually different settings when the settings are manually changed during runtime of the program. Search for the Settings class. What makes this class a singleton object and is a singleton object SOLID? The hospital types codes are stored in a python module hospital_types.py . Is this a logical solution? Is there an alternative solution for these kind of local settings and parameters?","title":"4. The local settings object"},{"location":"week1.1.html#exercise-5-class-diagram","text":"Draw the class diagram for this program.","title":"Exercise 5. Class diagram"},{"location":"week1.2.html","text":"Week 1.2: Classes and instances \u00b6 Introduction \u00b6 Photosynthesis is the process by which plants and certain algae convert light energy into chemical energy that can be stored and used to drive the organism's activities. Though different varieties of photosynthesis exist, the overall equation for the type that occurs in plants is as follows: \\(6CO_2 + 6H_2O -> C_6H_{12}O_6 + 6O_2 + energy\\) In this exercise, we are going to realise a very simple model of this process. Assignment 1: the Atom class \u00b6 1a. Create a class Atom that is a representation of any atom in the periodic table. Make sure that when a concrete atom is instantiated, it is given its symbol, its atomic number and the number of neutrons in the core. Store those parameters in the created object. 1b. Create a method proton_number that returns the number of protons in the nucleus; make another method mass_number that returns the sum of protons and neutrons in the nucleus. Isotopes are types of atoms that have the same number of atomic number but a different number of neutrons in the core. So, e.g. 'normal' hydrogen has 1 proton and 1 neutron, but it also comes in the form of deuterium (1 proton and 2 neutrons) or even tritium (1 proton and 3 neutrons). 1c. Create a method isotope in the class Atom . When this method is called, the normal number of neutrons must be replaced by whatever number is provided to this method. 1d. We define an atom A to be less than another atom B if their proton number is the same (i.e. it is the same element) but the mass number of A is less than the mass number of B. Implement the methods that checks whether two isotopes of the same element are equal to each other, or less than or greater than each other. Raise an exception when the check called with different type of elements. You can use the code below to test your implementation. protium = Atom ( 'H' , 1 , 1 ) deuterium = Atom ( 'H' , 1 , 2 ) oxygen = Atom ( 'O' , 8 , 8 ) tritium = Atom ( 'H' , 1 , 2 ) tritium . isotope ( 3 ) assert tritium . neutrons == 3 assert tritium . mass_number () == 4 assert protium < deuterium assert deuterium <= tritium assert tritium >= protium print ( oxygen > tritium ) # <-- this should raise an Exception Assignment 2: the Molecule class \u00b6 A molecule is a neutral group of two or more atoms. 2a. Create the class Molecule . When creating an instance of this class, a list of tuples of two values (a pair ) is given. The first element of this pair is the Atom-object, the second element is the number of atoms of that type that is put into the molecule. Thus, the following code snippet creates a water-molecule: hydrogen = Atom ( 'H' , 1 , 1 ) oxygen = Atom ( 'O' , 8 , 8 ) water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) 2b. Make sure that when we print individual molecules, we get somehing resembling the correct chemical formula (you don't have to take the exact protocol into account). So, e.g. print (water) would render H2O . Make sure that the number 1 is omitted in the representation. 2c In our small implementation, molecules that are created can never change (they are immutable ). However, we can add two molecules together in order to create a new molecule. Implement this method in the class Molecule . Creating molecules this way is, of course, not really possible. However, because of educational reasons we pretend that this is an ok way to work. You can use the code below to test your implementation: hydrogen = Atom ( 'H' , 1 , 1 ) carbon = Atom ( 'C' , 6 , 6 ) oxygen = Atom ( 'O' , 8 , 8 ) water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) co2 = Molecule ( [ ( carbon , 1 ), ( oxygen , 2 ) ]) print ( water ) # H2O print ( co2 ) # CO2 print ( water + co2 ) # H2OCO2 Assignment 3: The Chloroplast class \u00b6 As a final assignment, we are going to make a (very, very) simplified version of the photosynthesis process; basically, we are only going to implement the formula stated above. 3a. Create the class Chloroplast . When creating objects of this type, make sure two fields water and co2 are initialised at value 0 . 3b. Implement the following functionality: make a methode add_molecule in which we can add water or carbondioxyde molecules. When we add either of them, the corresponding field is incrementend by one. When we add something else than water of carbondioxyde, a ValueError is raised, but the program continues to function. If nothing else happens, this method returns an empty list 3c. When we have added a total of 6 CO2-molecules and 12 H2O-molecules, we start of the photosyntheses. We decrease the fields water and co2 with 6 and 12 respectively and create three new molecules: C6H12O6 , O2 and H2O . In this case, the method returns a list of tuples: 1 molecule of sugar, 6 molecules of oxygen and 6 molecules of water (as per the general formula stated above). 3d. Make sure thwat when we print this instance of chloroplast, we get an idea of how many molecules of water and co2 are already stored in it. You can use the following script to check your implementation water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) co2 = Molecule ( [ ( carbon , 1 ), ( oxygen , 2 ) ]) demo = Chloroplast () els = [ water , co2 ] while ( True ): print ( ' \\n What molecule would you like to add?' ) print ( '[1] Water' ) print ( '[2] carbondioxyde' ) print ( 'Please enter your choice: ' , end = '' ) try : choice = int ( input ()) res = demo . add_molecule ( els [ choice - 1 ]) if ( len ( res ) == 0 ): print ( demo ) else : print ( ' \\n === Photosynthesis!' ) print ( res ) print ( demo ) except Exception : print ( ' \\n === That is not a valid choice.' ) Wrap up \u00b6 Make sure your code follows the SOLID principles. Do you see any refactoring-possibilities? Did you use constants where possible? Have you identified all the stuff that stayed the same and seperated that from all the stuff that changed...?","title":"Week 1.2: Classes and instances"},{"location":"week1.2.html#week-12-classes-and-instances","text":"","title":"Week 1.2: Classes and instances"},{"location":"week1.2.html#introduction","text":"Photosynthesis is the process by which plants and certain algae convert light energy into chemical energy that can be stored and used to drive the organism's activities. Though different varieties of photosynthesis exist, the overall equation for the type that occurs in plants is as follows: \\(6CO_2 + 6H_2O -> C_6H_{12}O_6 + 6O_2 + energy\\) In this exercise, we are going to realise a very simple model of this process.","title":"Introduction"},{"location":"week1.2.html#assignment-1-the-atom-class","text":"1a. Create a class Atom that is a representation of any atom in the periodic table. Make sure that when a concrete atom is instantiated, it is given its symbol, its atomic number and the number of neutrons in the core. Store those parameters in the created object. 1b. Create a method proton_number that returns the number of protons in the nucleus; make another method mass_number that returns the sum of protons and neutrons in the nucleus. Isotopes are types of atoms that have the same number of atomic number but a different number of neutrons in the core. So, e.g. 'normal' hydrogen has 1 proton and 1 neutron, but it also comes in the form of deuterium (1 proton and 2 neutrons) or even tritium (1 proton and 3 neutrons). 1c. Create a method isotope in the class Atom . When this method is called, the normal number of neutrons must be replaced by whatever number is provided to this method. 1d. We define an atom A to be less than another atom B if their proton number is the same (i.e. it is the same element) but the mass number of A is less than the mass number of B. Implement the methods that checks whether two isotopes of the same element are equal to each other, or less than or greater than each other. Raise an exception when the check called with different type of elements. You can use the code below to test your implementation. protium = Atom ( 'H' , 1 , 1 ) deuterium = Atom ( 'H' , 1 , 2 ) oxygen = Atom ( 'O' , 8 , 8 ) tritium = Atom ( 'H' , 1 , 2 ) tritium . isotope ( 3 ) assert tritium . neutrons == 3 assert tritium . mass_number () == 4 assert protium < deuterium assert deuterium <= tritium assert tritium >= protium print ( oxygen > tritium ) # <-- this should raise an Exception","title":"Assignment 1: the Atom class"},{"location":"week1.2.html#assignment-2-the-molecule-class","text":"A molecule is a neutral group of two or more atoms. 2a. Create the class Molecule . When creating an instance of this class, a list of tuples of two values (a pair ) is given. The first element of this pair is the Atom-object, the second element is the number of atoms of that type that is put into the molecule. Thus, the following code snippet creates a water-molecule: hydrogen = Atom ( 'H' , 1 , 1 ) oxygen = Atom ( 'O' , 8 , 8 ) water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) 2b. Make sure that when we print individual molecules, we get somehing resembling the correct chemical formula (you don't have to take the exact protocol into account). So, e.g. print (water) would render H2O . Make sure that the number 1 is omitted in the representation. 2c In our small implementation, molecules that are created can never change (they are immutable ). However, we can add two molecules together in order to create a new molecule. Implement this method in the class Molecule . Creating molecules this way is, of course, not really possible. However, because of educational reasons we pretend that this is an ok way to work. You can use the code below to test your implementation: hydrogen = Atom ( 'H' , 1 , 1 ) carbon = Atom ( 'C' , 6 , 6 ) oxygen = Atom ( 'O' , 8 , 8 ) water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) co2 = Molecule ( [ ( carbon , 1 ), ( oxygen , 2 ) ]) print ( water ) # H2O print ( co2 ) # CO2 print ( water + co2 ) # H2OCO2","title":"Assignment 2: the Molecule class"},{"location":"week1.2.html#assignment-3-the-chloroplast-class","text":"As a final assignment, we are going to make a (very, very) simplified version of the photosynthesis process; basically, we are only going to implement the formula stated above. 3a. Create the class Chloroplast . When creating objects of this type, make sure two fields water and co2 are initialised at value 0 . 3b. Implement the following functionality: make a methode add_molecule in which we can add water or carbondioxyde molecules. When we add either of them, the corresponding field is incrementend by one. When we add something else than water of carbondioxyde, a ValueError is raised, but the program continues to function. If nothing else happens, this method returns an empty list 3c. When we have added a total of 6 CO2-molecules and 12 H2O-molecules, we start of the photosyntheses. We decrease the fields water and co2 with 6 and 12 respectively and create three new molecules: C6H12O6 , O2 and H2O . In this case, the method returns a list of tuples: 1 molecule of sugar, 6 molecules of oxygen and 6 molecules of water (as per the general formula stated above). 3d. Make sure thwat when we print this instance of chloroplast, we get an idea of how many molecules of water and co2 are already stored in it. You can use the following script to check your implementation water = Molecule ( [ ( hydrogen , 2 ), ( oxygen , 1 ) ] ) co2 = Molecule ( [ ( carbon , 1 ), ( oxygen , 2 ) ]) demo = Chloroplast () els = [ water , co2 ] while ( True ): print ( ' \\n What molecule would you like to add?' ) print ( '[1] Water' ) print ( '[2] carbondioxyde' ) print ( 'Please enter your choice: ' , end = '' ) try : choice = int ( input ()) res = demo . add_molecule ( els [ choice - 1 ]) if ( len ( res ) == 0 ): print ( demo ) else : print ( ' \\n === Photosynthesis!' ) print ( res ) print ( demo ) except Exception : print ( ' \\n === That is not a valid choice.' )","title":"Assignment 3: The Chloroplast class"},{"location":"week1.2.html#wrap-up","text":"Make sure your code follows the SOLID principles. Do you see any refactoring-possibilities? Did you use constants where possible? Have you identified all the stuff that stayed the same and seperated that from all the stuff that changed...?","title":"Wrap up"},{"location":"week1.3.html","text":"Week 1.3: Multiple Class Interaction \u00b6 In this exercise, we will be building a relatively complexe system that consists of serveral classes that need to coordinate certain events. In the process, we introduce the concept of asynchronicity, generators, parallellism and message queues. The central idea is that we have some data that needs to be harvested, transformed and distributed. We build this application in several more or less independent steps, in order to bring the idea home that seperation and compartmentalization are good things. Step 1: Producing data \u00b6 Download the file dSST.csv and study its contents. This is a comma-seperated datafile consisting of the average monthly global temperature anomalies between the years 1880-2021. These temperatures are based on the GISS Surface Temperature Analysis (GISTEMP v4), an estimate of global surface temperature change. Anomalies are defined relative to a base period of 1951-1980. 1a: from csv to json \u00b6 We want this data to be made available in json instead of csv. The big difference between these two date formats is that the first line of a csv-file contains all the properties ( keys ) of the data, while json needs to have these properties repeated. Have a look at the following example: key1,key2 1880,3.14 1881,2.87 which in json would be [{ \"key1\" : 1880 , \"key2\" : 3.14 },{ \"key1\" : 1881 , \"key2\" : 2.87 }] Create a class CsvConverter which does exactly this. Make sure that when you create an instance of this class, the header (first line) of a csv-file is added. Since this is usually just a string, make sure to split this line using str.split(',') in order to create a list of keys. Add a method csv_to_json() which receives a list of lines from a csv-file and returns this data as json. Again, since the lines are just strings, use split to transform each line into a list of values. Make sure that the amount of items in each line corresponds to the number of elements in the header that you stored in the object (make us of assert and issue a nice warning when the numbers don't match). Use the following code as an example for your implementation: >>> keys = 'a,b,c,d' >>> vals = '3,2,1,5' >>> dict ( zip ( keys . split ( ',' ), vals . split ( ',' ))) { 'a' : '3' , 'b' : '2' , 'c' : '1' , 'd' : '5' } >>> You may need to use json.dumps() in your method to make sure that the returned value is indeed valid json (past it into jsonparser.org when in doubt). 1b. getting the data \u00b6 Create a class Reader which gets the location of a csv-file in its constructor (you might want to default this to our dSSST.csv ). Also in the constructor, create an instance of the CvsConcerter and store that in the object's memory space. Reader -objects will read the given csv-files in strides of a certain amount of lines. In order to do this, you will need to do some bookkeeping within the object itself: you will need to store both the number of lines that are read in one go and also a pointer to the current line in the file. Add a method get_lines() to the Reader -class. In this method, the next stride of lines is returned as json. You can use linecache to read certain lines of the data-file. So, given that the first line of our csv-file contains its keys, a flow could be like this (output omitted for readability): red = Reader ( 'dSST.csv' ) red . get_lines () #returns lines 2-6 as json reg . get_lines () #returns lines 7-11 as json reg . get_lines () #returns lines 12-16 as json If there are no more lines in the data-file, the method get_lines() needs to return an empty string. Step 2: Consuming the data \u00b6 We are going to create two classes, AverageYear and AverageMonth that make use of this temperature-data that is being provided by objects of the Reader -class. There are, of course, several ways in which you can make these Reader -objects available in the consuming classes: we can create a new Reader -object when initializing our consumer, or we can make one Reader -object and give that object to the initializer of the consumers. What do you think are the pros and cons of both approaches? The first consuming class will show the average temperature anomaly for the complete set of five years that our Reader is returning. the second class needs to show the average montly anomaly for the same five years. Please note that the number of columns is larger than the number of months within the year (the last few columns are some kind of special meteorological averages), so be sure to take the right data. Of course, in both classes you can make use of pandas, numpy, matplotlib and all kind of libraries you are used to in order to make some sort of visualisation. Within both classes, use consecutive calls to get_lines() in order to get the next stride of lines from this data-class. Stop calling this method whenever this method returns an empty string. You don't need to make an incremental plot with each new call to get_lines() (thought that would be a nice addition): it is sufficient when you repaint your visualisation every time new data gets returned. In the end, the architecture would look as follows: There are several issues with this architecture, regardsless of the way in which you provided the consuming classes with the Reader -objects. In the following step, we are going to decouple these classes in order to create a more robust and versatile system. Step 3: The observer pattern \u00b6 During the theoretical part, the observer pattern was briefly described. For easy reference, the sequence diagram that was shown is repeated here: In this step, we are going to refactor the classes you've created in step 3 in order to realise this design pattern. 3a: Extending the reader \u00b6 Create two methods in the Reader -class, add_observer() and remove_observer() so that we can add and remove observers. Make sure that when we create a new instance of the Reader , you create an empty set within the memory-space of the Reader . A call to the first method should add the given observer to this list, a call to the second call will (drumm-roll) remove the observer from the list if it is present. If the observer is not present in the list, make sure that nothing happens (removing a non-existent observer from this list is not a reason the crash a system) Next, add a method to notify_observers() to Reader . When called, this method needs to iterate over all the registered observers and call update() on each of them. Now, change the Reader so that the next five lines (the stride ) are produced every five seconds (you can make use of time.sleep(5) in order to accomplish this) and every time new data is read a call to notify_observers() is made. 3b: Extending the consumers \u00b6 Now we need to change the two consumers we created in step 2. Instead of making them responsible for the call to next_lines() , we just let them react to the updates of the Reader -class. Whenever this class has new data available, it will run notify_observers() which in turn will call update() on the observer. Make sure that whenever the update -method is called from the producer, the same visualisation that you made in step 2 is rendered. Please refer to the listing below to get an idea of the infrastructure that is required: prod = Reader ( 'dSST.csv' ) cons1 = AverageYear () cons2 = AverageMonth () prod . register_observer ( cons1 ) prod . register_observer ( cons2 ) If all goes well, some of the problems we encountered earlier are more or less solved. However, this architecture has some problems of its own. Can you see where this goes wrong and how you can solve them?","title":"Week 1.3: Multiple Class Interaction"},{"location":"week1.3.html#week-13-multiple-class-interaction","text":"In this exercise, we will be building a relatively complexe system that consists of serveral classes that need to coordinate certain events. In the process, we introduce the concept of asynchronicity, generators, parallellism and message queues. The central idea is that we have some data that needs to be harvested, transformed and distributed. We build this application in several more or less independent steps, in order to bring the idea home that seperation and compartmentalization are good things.","title":"Week 1.3: Multiple Class Interaction"},{"location":"week1.3.html#step-1-producing-data","text":"Download the file dSST.csv and study its contents. This is a comma-seperated datafile consisting of the average monthly global temperature anomalies between the years 1880-2021. These temperatures are based on the GISS Surface Temperature Analysis (GISTEMP v4), an estimate of global surface temperature change. Anomalies are defined relative to a base period of 1951-1980.","title":"Step 1: Producing data"},{"location":"week1.3.html#1a-from-csv-to-json","text":"We want this data to be made available in json instead of csv. The big difference between these two date formats is that the first line of a csv-file contains all the properties ( keys ) of the data, while json needs to have these properties repeated. Have a look at the following example: key1,key2 1880,3.14 1881,2.87 which in json would be [{ \"key1\" : 1880 , \"key2\" : 3.14 },{ \"key1\" : 1881 , \"key2\" : 2.87 }] Create a class CsvConverter which does exactly this. Make sure that when you create an instance of this class, the header (first line) of a csv-file is added. Since this is usually just a string, make sure to split this line using str.split(',') in order to create a list of keys. Add a method csv_to_json() which receives a list of lines from a csv-file and returns this data as json. Again, since the lines are just strings, use split to transform each line into a list of values. Make sure that the amount of items in each line corresponds to the number of elements in the header that you stored in the object (make us of assert and issue a nice warning when the numbers don't match). Use the following code as an example for your implementation: >>> keys = 'a,b,c,d' >>> vals = '3,2,1,5' >>> dict ( zip ( keys . split ( ',' ), vals . split ( ',' ))) { 'a' : '3' , 'b' : '2' , 'c' : '1' , 'd' : '5' } >>> You may need to use json.dumps() in your method to make sure that the returned value is indeed valid json (past it into jsonparser.org when in doubt).","title":"1a: from csv to json"},{"location":"week1.3.html#1b-getting-the-data","text":"Create a class Reader which gets the location of a csv-file in its constructor (you might want to default this to our dSSST.csv ). Also in the constructor, create an instance of the CvsConcerter and store that in the object's memory space. Reader -objects will read the given csv-files in strides of a certain amount of lines. In order to do this, you will need to do some bookkeeping within the object itself: you will need to store both the number of lines that are read in one go and also a pointer to the current line in the file. Add a method get_lines() to the Reader -class. In this method, the next stride of lines is returned as json. You can use linecache to read certain lines of the data-file. So, given that the first line of our csv-file contains its keys, a flow could be like this (output omitted for readability): red = Reader ( 'dSST.csv' ) red . get_lines () #returns lines 2-6 as json reg . get_lines () #returns lines 7-11 as json reg . get_lines () #returns lines 12-16 as json If there are no more lines in the data-file, the method get_lines() needs to return an empty string.","title":"1b. getting the data"},{"location":"week1.3.html#step-2-consuming-the-data","text":"We are going to create two classes, AverageYear and AverageMonth that make use of this temperature-data that is being provided by objects of the Reader -class. There are, of course, several ways in which you can make these Reader -objects available in the consuming classes: we can create a new Reader -object when initializing our consumer, or we can make one Reader -object and give that object to the initializer of the consumers. What do you think are the pros and cons of both approaches? The first consuming class will show the average temperature anomaly for the complete set of five years that our Reader is returning. the second class needs to show the average montly anomaly for the same five years. Please note that the number of columns is larger than the number of months within the year (the last few columns are some kind of special meteorological averages), so be sure to take the right data. Of course, in both classes you can make use of pandas, numpy, matplotlib and all kind of libraries you are used to in order to make some sort of visualisation. Within both classes, use consecutive calls to get_lines() in order to get the next stride of lines from this data-class. Stop calling this method whenever this method returns an empty string. You don't need to make an incremental plot with each new call to get_lines() (thought that would be a nice addition): it is sufficient when you repaint your visualisation every time new data gets returned. In the end, the architecture would look as follows: There are several issues with this architecture, regardsless of the way in which you provided the consuming classes with the Reader -objects. In the following step, we are going to decouple these classes in order to create a more robust and versatile system.","title":"Step 2: Consuming the data"},{"location":"week1.3.html#step-3-the-observer-pattern","text":"During the theoretical part, the observer pattern was briefly described. For easy reference, the sequence diagram that was shown is repeated here: In this step, we are going to refactor the classes you've created in step 3 in order to realise this design pattern.","title":"Step 3: The observer pattern"},{"location":"week1.3.html#3a-extending-the-reader","text":"Create two methods in the Reader -class, add_observer() and remove_observer() so that we can add and remove observers. Make sure that when we create a new instance of the Reader , you create an empty set within the memory-space of the Reader . A call to the first method should add the given observer to this list, a call to the second call will (drumm-roll) remove the observer from the list if it is present. If the observer is not present in the list, make sure that nothing happens (removing a non-existent observer from this list is not a reason the crash a system) Next, add a method to notify_observers() to Reader . When called, this method needs to iterate over all the registered observers and call update() on each of them. Now, change the Reader so that the next five lines (the stride ) are produced every five seconds (you can make use of time.sleep(5) in order to accomplish this) and every time new data is read a call to notify_observers() is made.","title":"3a: Extending the reader"},{"location":"week1.3.html#3b-extending-the-consumers","text":"Now we need to change the two consumers we created in step 2. Instead of making them responsible for the call to next_lines() , we just let them react to the updates of the Reader -class. Whenever this class has new data available, it will run notify_observers() which in turn will call update() on the observer. Make sure that whenever the update -method is called from the producer, the same visualisation that you made in step 2 is rendered. Please refer to the listing below to get an idea of the infrastructure that is required: prod = Reader ( 'dSST.csv' ) cons1 = AverageYear () cons2 = AverageMonth () prod . register_observer ( cons1 ) prod . register_observer ( cons2 ) If all goes well, some of the problems we encountered earlier are more or less solved. However, this architecture has some problems of its own. Can you see where this goes wrong and how you can solve them?","title":"3b: Extending the consumers"},{"location":"week1.4.html","text":"Week 1.4: Generators and Map-Reduce \u00b6 Introduction \u00b6","title":"Week 1.4: Generators and Map-Reduce"},{"location":"week1.4.html#week-14-generators-and-map-reduce","text":"","title":"Week 1.4: Generators and Map-Reduce"},{"location":"week1.4.html#introduction","text":"","title":"Introduction"},{"location":"week1.5.html","text":"Week 1.5: Divide and Conquer Algorithms \u00b6 Introduction \u00b6","title":"Week 1.5: Divide and Conquer Algorithms"},{"location":"week1.5.html#week-15-divide-and-conquer-algorithms","text":"","title":"Week 1.5: Divide and Conquer Algorithms"},{"location":"week1.5.html#introduction","text":"","title":"Introduction"}]}